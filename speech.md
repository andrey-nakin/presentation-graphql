# Вступление

Коллеги, добрый день. Вашему вниманию предлагается доклад «GraphQL как способ организации
back-end API».

В данном докладе я хотел бы дать краткий обзор технологии GraphQL. Те, кто хорошо с ней знаком, наверное не найдут для
себя ничего нового. По ходу доклада будут ссылки в виде QR кодов, и те, кто заинтересовался, могут делать скриншоты.
Впрочем, если кто не успеет или пропустит интересный слайд, в конце я дам ссылку на исходники данной презентации.

# Введение

Доклад начинается с краткого введения в технологию. Далее я расскажу о том, чем GraphQL может помочь в многосервисных
приложениях. Также упомяну о некоторых проблемах данной технологии и совсем коротко пробегусь по
решениям на её основе.

GraphQL - формально - это спецификация, которая включает в себя язык запросов, язык описания схем и так далее.
Изначально она была создана инженерами компании Facebook в 2012 году, спустя несколько лет технология была выпущена на
свободу и в настоящее время её развитием занимается некоммерческая организация GraphQL Foundation.

Целью создания GraphQL, как мне кажется, было решение типичных проблем типичного RESTful API. Давайте посмотрим на эти
проблемы и как GraphQL их решает.

Рассмотрим в качестве примера некое API, которое возвращает данные кадрового отдела. API состоит из трёх точек входа,
которые возвращают информацию о филиалах предприятия, их дочерних отделах и сотрудниках, каждый из которых работает в
одном из филиалов. Как мы видим, каждая точка входа возвращает плоские объекты без избыточных полей, что делает наше API
полностью нормализованным. Также отметим, что на стороне back-end такое API реализуется при помощи простых операций,
таких как выбор одиночного объекта по его идентификатору и выборка нескольких однотипных объектов по списку
идентификаторов.

Теперь нам необходимо решить следующую задачу: по известному идентификатору сотрудника получить название
филиала, в котором он работает.

Если оставаться в рамках данного API, не менять его, то для решения задачи нужно выполнить три последовательных запроса
к back-end. Такое решение имеет известные проблемы. Во-первых, общее время операции вырастет примерно втрое. Заметим,
что иногда время отклика, например, мобильного приложения, является важной частью его удобства для пользователей.
Во-вторых, клиентский код заметно усложняется, как минимум в силу утроения логики по обработке результатов запроса к
серверу. В-третьих, есть опасность получения несогласованных данных.

Можно модифицировать API путём его денормализации, добавил дополнительные поля в тип Employee. Иногда это просто и
оправданное решение. Но оно довольно частное, нет ли более общего решения?

Да, есть. Мы можем добавить информацию об отделе и его филиале непосредственно в данные сотрудника. Конечно, добавил при
этом дополнительные параметры в наше API для того, чтобы данные отдела и филиала отправлялись клиенту только тогда,
когда они точно нужны. При этом тип Employee перестал быть «плоским», в нём появились иерархичные данные.

Наше решение имеет следующий недостаток: сервер отправляет клиенту много лишних данных. Нам нужно только название
филиала, а мы кроме этого получаем несколько ненужным полей включая, между прочим, фотографию сотрудника - поле, которое
может быть весьма тяжёлым как для сервера, так и для клиента, не говоря уже о повышенном расходе трафика.

Поэтому мы добавим в наше API ещё несколько параметров, которые отключают отправку полей, которые нам не нужны в данный
момент. В результаты мы получили название филиала в результате одного запроса к сереру и в составе компактного пакета
данных.

Итак, задача решена и причём эффективным образом. Но по мере решения подобных однотипных задач начинают копиться другие
проблемы.

С точки зрения клиента, наше API стало весьма громоздким. Клиенту нужно помнить или записывать множество
конфигурационных параметров. А если в API добавятся какие-нибудь новые поля? Их ведь тоже надо будет как-то отключать?
То есть, чтобы поддерживать эффективность работы, клиенту необходимо отслеживать изменения в API.

С точки зрения сервера всё ещё хуже. Все это обилие конфигурационных параметров нужно поддерживать, а значит наша
бизнес-логика будет весьма зашумлена кодом, отвечающим за возврат данных клиенту. И сама бизнес-логика усложнилась, в
дополнение к операциям по выборке данных добавилась логика композиции.

Как мы видим, возникает запрос на какое-нибудь общее решение. Разрабочику на стороне клиента хотелось бы не запоминать
кучу
параметров, а иметь какой-нибудь простой набор правил по выбору нужных полей. То есть, нужен некий язык запросов. С
другой стороны, back-end разработчику хотелось бы иметь библиотеку или фреймворк, которые взяли бы на себя всю рутинную
работу по разбору этого языка, по композиции данных и так далее.

Одним из таких решений является GraphQL.

Давайте посмотрим, как это может выглядеть на стороне клиента. Слева - пример GraphQL запроса. В нём мы указываем имя
запроса, его параметры и перечисляем поля, которые нам нужно получить от сервера. Справа - результат запроса. Как видно,
сервер прислал нам ровно то, что мы просили, ни одного лишнего поля. Разработчику не надо помнить названия параметров,
достаточно изучить весьма простой язык запросов.

А что на сервере? А на сервере основную работу на себя взял фреймворк.

Разработчику на back-end остаётся написать небольшие процедуры, в GraphQL они называются резольверы. В данном случае
наши резольверы будут просто искать отдельный плоский объект по его идентификатору. Ну или несколько однотипных объектов
по списку идентификаторов. Вы заметили, что на back-end мы опять вернулись к тому же самому, что было в изначальному
RESTful API?

Реализация на back-end осталась простой, даже тривиальной. Зато у клиентов появился довольно мощный язык запросов.

Или вот ещё пример GraphQL запроса. Мы в одном обращении к серверу запрашиваем три объекта разных типов.

Итак, с использованием GraphQL жизнь разработчика клиентов (а это зачастую front-end разработчики, но не только) засияла
новыми красками.

Также GraphQL упрощает жизнь системному аналитику. Вспомним типичный современный проект: Agile во все поля, итерационная
разработка, список требований зачастую неполный. В общем, проектировать API приходится в ситуации полной
неопределённости. И в такой ситуации хочется заложить в API максимальную возможную гибкость. С GraphQL это довольно
просто: мы определяем типы объектов, связи между ними и основные операции. А вот комбинация выборки объектов уже не наша
головная боль, это всё отдаётся на откуп клиентам API.

Но сразу заметим, что GraphQL лучше всего работает в типичных web-приложениях, таких как тот же самый Facebook. В
некоторых специфичных случаях GraphQL может оказаться бесполезным.

