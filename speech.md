# Вступление

Коллеги, добрый день. Вашему вниманию предлагается доклад «GraphQL как способ организации
back-end API».

В данном докладе я хотел бы дать краткий обзор технологии GraphQL. Те, кто хорошо с ней знаком, наверное не найдут для
себя ничего нового. По ходу доклада будут ссылки в виде QR кодов, и те, кто заинтересовался, могут делать скриншоты.
Впрочем, если кто не успеет или пропустит интересный слайд, в конце я дам ссылку на исходники данной презентации.

# Введение

Доклад начинается с краткого введения в технологию. Далее я расскажу о том, чем GraphQL может помочь в многосервисных
приложениях. Также упомяну о некоторых проблемах данной технологии и совсем коротко пробегусь по
решениям на её основе.

GraphQL - формально - это спецификация, которая включает в себя язык запросов, язык описания схем и так далее.
Изначально она была создана инженерами компании Facebook в 2012 году, спустя несколько лет технология была выпущена на
свободу и в настоящее время её развитием занимается некоммерческая организация GraphQL Foundation.

Целью создания GraphQL, как мне кажется, было решение типичных проблем типичного RESTful API. Давайте посмотрим на эти
проблемы и как GraphQL их решает.

Рассмотрим в качестве примера некое API, которое возвращает данные кадрового отдела. API состоит из трёх точек входа,
которые возвращают информацию о филиалах предприятия, их дочерних отделах и сотрудниках, каждый из которых работает в
одном из филиалов. Как мы видим, каждая точка входа возвращает плоские объекты без избыточных полей, что делает наше API
полностью нормализованным. Также отметим, что на стороне back-end такое API реализуется при помощи простых операций,
таких как выбор одиночного объекта по его идентификатору и выборка нескольких однотипных объектов по списку
идентификаторов.

Теперь нам необходимо решить следующую задачу: по известному идентификатору сотрудника получить название
филиала, в котором он работает.

Если оставаться в рамках данного API, не менять его, то для решения задачи нужно выполнить три последовательных запроса
к back-end. Такое решение имеет известные проблемы. Во-первых, общее время операции вырастет примерно втрое. Заметим,
что иногда время отклика, например, мобильного приложения, является важной частью его удобства для пользователей.
Во-вторых, клиентский код заметно усложняется, как минимум в силу утроения логики по обработке результатов запроса к
серверу. В-третьих, есть опасность получения несогласованных данных.

Можно модифицировать API путём его денормализации, добавил дополнительные поля в тип Employee. Иногда это просто и
оправданное решение. Но оно довольно частное, нет ли более общего решения?

Да, есть. Мы можем добавить информацию об отделе и его филиале непосредственно в данные сотрудника. Конечно, добавил при
этом дополнительные параметры в наше API для того, чтобы данные отдела и филиала отправлялись клиенту только тогда,
когда они точно нужны. При этом тип Employee перестал быть «плоским», в нём появились иерархичные данные.

Наше решение имеет следующий недостаток: сервер отправляет клиенту много лишних данных. Нам нужно только название
филиала, а мы кроме этого получаем несколько ненужным полей включая, между прочим, фотографию сотрудника - поле, которое
может быть весьма тяжёлым как для сервера, так и для клиента, не говоря уже о повышенном расходе трафика.

Поэтому мы добавим в наше API ещё несколько параметров, которые отключают отправку полей, которые нам не нужны в данный
момент. В результаты мы получили название филиала в результате одного запроса к сереру и в составе компактного пакета
данных.

Итак, задача решена и причём эффективным образом. Но по мере решения подобных однотипных задач начинают копиться другие
проблемы.

С точки зрения клиента, наше API стало весьма громоздким. Клиенту нужно помнить или записывать множество
конфигурационных параметров. А если в API добавятся какие-нибудь новые поля? Их ведь тоже надо будет как-то отключать?
То есть, чтобы поддерживать эффективность работы, клиенту необходимо отслеживать изменения в API.

С точки зрения сервера всё ещё хуже. Все это обилие конфигурационных параметров нужно поддерживать, а значит наша
бизнес-логика будет весьма зашумлена кодом, отвечающим за возврат данных клиенту. И сама бизнес-логика усложнилась, в
дополнение к операциям по выборке данных добавилась логика композиции.

Как мы видим, возникает запрос на какое-нибудь общее решение. Разрабочику на стороне клиента хотелось бы не запоминать
кучу
параметров, а иметь какой-нибудь простой набор правил по выбору нужных полей. То есть, нужен некий язык запросов. С
другой стороны, back-end разработчику хотелось бы иметь библиотеку или фреймворк, которые взяли бы на себя всю рутинную
работу по разбору этого языка, по композиции данных и так далее.

Одним из таких решений является GraphQL.

Давайте посмотрим, как это может выглядеть на стороне клиента. Слева - пример GraphQL запроса. В нём мы указываем имя
запроса, его параметры и перечисляем поля, которые нам нужно получить от сервера. Справа - результат запроса. Как видно,
сервер прислал нам ровно то, что мы просили, ни одного лишнего поля. Разработчику не надо помнить названия параметров,
достаточно изучить весьма простой язык запросов.

А что на сервере? А на сервере основную работу на себя взял фреймворк.

Разработчику на back-end остаётся написать небольшие процедуры, в GraphQL они называются резольверы. В данном случае
наши резольверы будут просто искать отдельный плоский объект по его идентификатору. Ну или несколько однотипных объектов
по списку идентификаторов. Вы заметили, что на back-end мы опять вернулись к тому же самому, что было в изначальному
RESTful API?

Реализация на back-end осталась простой, даже тривиальной. Зато у клиентов появился довольно мощный язык запросов.

Или вот ещё пример GraphQL запроса. Мы в одном обращении к серверу запрашиваем три объекта разных типов.

Итак, с использованием GraphQL жизнь разработчика клиентов (а это зачастую front-end разработчики, но не только) засияла
новыми красками.

Также GraphQL упрощает жизнь системному аналитику. Вспомним типичный современный проект: Agile во все поля, итерационная
разработка, список требований зачастую неполный. В общем, проектировать API приходится в ситуации полной
неопределённости. И в такой ситуации хочется заложить в API максимальную возможную гибкость. С GraphQL это довольно
просто: мы определяем типы объектов, связи между ними и основные операции. А вот комбинация выборки объектов уже не наша
головная боль, это всё отдаётся на откуп клиентам API.

Но сразу заметим, что GraphQL лучше всего работает в типичных web-приложениях, таких как тот же самый Facebook. В
некоторых специфичных случаях GraphQL может оказаться бесполезным.

Но вернёмся к GraphQL. Помимо собственно QL - языка запросов - в нём есть специальный язык описания схем, так называемый
SDL. На этом языке пишут так называемую схему, то есть полное описание вашего API.

В самом простом случае схема состоит из следующих элементов. Это типы объектов, связи между типами, операции чтения
данных с сервера и операции изменения данных на сервере.

Схема описывает API исчерпывающим образом. И эта информация нужна клиентам вашего API. Для этого в GraphQL есть механизм
интроспекции. Это стандартный способ получить информацию об элементах API через само API. Например, следующим запросом
мы получаем список полей у объекта типа Employee.

Схема может содержать текстовую документацию. И эта документация, в отличие от комментариев, доступна через
интроспекцию, то есть является полноценной частью API.

Также схема может содержать пользовательские метаданные с произвольной семантикой. Например, в данном примере мы даём
понять, что поле numOfLogins доступно только пользователям, имеющим роль администратора. Это наша пользовательская
директива, и её наполнение реализуется на стороне back-end.

Любое API меняется со временем. А жизненный цикл вашего back-end и ваших клиентов может весьма различаться. Поэтому в
REST считается хорошей практикой фиксировать версии вашего API, когда изменения в них становятся обратно несовместимыми.
При этом клиенту нужно явно указать нужную версию, а серверу нужно поддерживать всё актуальные версии.

В случае GraphQL, конечно, никто не запрещает вам иметь несколько версий схем и держать на сервере несколько реализаций.
Но официальной best practice является то, что в документации зовётся continuous evolution. Эта эволюция включает три
принципа:

Во-первых, нельзя менять семантику и формат существующих элементов API. Это очевидное требование, оно и в REST такое же.

А вот второй принцип характерен именно для GraphQL: мы, как правило, можем спокойно, не опасаясь поломать клиентов,
добавлять новые элементы в наше API. Просто потому, что клиенты о них не узнают, пока явно их не запросят.

Ну и третий принцип: устаревшие элементы API помечаем как deprecated. Дальше уже забота клиентов вовремя это обнаружить
и перейти на новые элементы. Как долго deprecated поля будут оставаться в API - это уже дело конкретного проекта и его
политики.

У меня нет цели, да и времени подробно рассказать о всех фишках GraphQL. Всё, что я успел рассказать выше, касается
простых приложений, состоящих из одного back-end модуля. В наше время такие приложения уже редкость, как правило
современное приложение состоит из многих компонентов, часть которых предоставляет своё API. Давайте посмотрим, какие
особые возможности для таких приложений есть в GraphQL.

Вернёмся к нашему приложению с API кадрового отдела. Только на этот раз это уже многомодульное приложение. Здесь каждый
модуль работает с объектами лишь одного типа. Каждый модуль имеет свою схему. Как видно из диаграммы, клиент имеет связи
с каждых из модулей.

В чём тут неудобство? Во-первых, клиенту нужно держать список адресов и схем и знать, куда обращаться в каждом случае.
Но это ещё терпимо. Хуже то, что мы уже не можем в обном обращении к back-end запросить разнотипные объекты. А как же
ваше хвалёное GraphQL?

Проблема решается введением нового компонента, так называемого маршрутизатора. Его функция - быть фасадом вашего API. Он
как бы имитирует GraphQL сервис. У него есть схема, которая является супермножеством всех нижележащих API.

Что мы видим? У клиента упростилась жизнь, он не задумывается, куда отправлять запросы, потому что точно входа теперь
одна. И мы можем в одном запросе обращаться к разным сервисам!

Сразу хотел бы сказать пару слов о GraphQL маршрутизаторе. Это не просто какой-то обычный прокси, это специализированное
ПО. Он знает структуру GraphQL запроса и умеет производить его диспетчеризацию между всеми сервисами. А ещё, как вы
понимаете, он должен быть довольно быстрым, чтобы не замедлять работу вашего API. О маршрутизаторах я ещё скажу пару
слов в конце доклада.

Но вернёмся к нашему приложению. Как видно, API ещё далеко от идеала. Нам нужно отдельно получить список отделов и
отдельно список сотрудников. А потом надо на клиенте, на JavaScript писать логику комбинации этих двух массивов данных.
Если честно, не совсем то, что ожидалось от GraphQL. Нам бы хотелось, чтобы эти разные API имели бОльшую связность.

Ну надо, так надо. Берём сервис отделов и протягиваем связь к сервису сотрудников. Теперь сервис отделов, если его
попросят, будет вместе с информацией об отделе возвращать и список его сотрудников.

Припоминаете, что мы это уже раньше проходили, в примерах в REST? Опять увеличение связности между компонентами
приложения, усложнение самих компонентов, много рутинного кода... Нет ли какого-нибудь общего решения?

